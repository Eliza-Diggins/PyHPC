<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>PyHPC.PyHPC_System.io API documentation</title>
<meta name="description" content="Core IO operations for passing objects to slurm, running commands, etc." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>PyHPC.PyHPC_System.io</code></h1>
</header>
<section id="section-intro">
<p>Core IO operations for passing objects to slurm, running commands, etc.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Core IO operations for passing objects to slurm, running commands, etc.
&#34;&#34;&#34;
import os
import pathlib as pt
import sys

sys.path.append(str(pt.Path(os.path.realpath(__file__)).parents[1]))
import json
from PyHPC.PyHPC_Core.log import get_module_logger
from PyHPC.PyHPC_Core.configuration import read_config
import pathlib as pt
import threading as t
import warnings
import toml
from PyHPC.PyHPC_Utils.text_display_utilities import get_options
from PyHPC.PyHPC_Utils.standard_utils import setInDict
from datetime import datetime

# generating screen locking #
screen_lock = t.Semaphore(value=1)  # locks off multi-threaded screen.
# --|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--#
# ------------------------------------------------------ Setup ----------------------------------------------------------#
# --|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--#
_location = &#34;PyHPC_System&#34;
_filename = pt.Path(__file__).name.replace(&#34;.py&#34;, &#34;&#34;)
_dbg_string = &#34;%s:%s:&#34; % (_location, _filename)
CONFIG = read_config()
modlog = get_module_logger(_location, _filename)
# - managing warnings -#
if not CONFIG[&#34;System&#34;][&#34;Logging&#34;][&#34;warnings&#34;]:
    warnings.filterwarnings(&#39;ignore&#39;)


# -------------------------------------------------------------------------------------------------------------------- #
#  Command Management ================================================================================================ #
# -------------------------------------------------------------------------------------------------------------------- #
def write_command_string(command: str, *args, **kwargs) -&gt; str:
    &#34;&#34;&#34;
    Returns the corresponding command string in the format &#39;&#39;command arg[0] arg[...] -k[0] v[0] ... -k[n] v[n].
    :param command: The command to run.
    :param args: Unflagged arguments to pass through the shell.
    :param kwargs: Flagged arguments to pass through the shell with corresponding &lt;b&gt;QUICK&lt;/b&gt; keys.
    :return: String.
    &#34;&#34;&#34;
    modlog.debug(&#34;Writing command %s with args %s and kwargs %s.&#34; % (command, args, kwargs))
    command_string = command

    # - Adding the arguments -#
    for arg in args:
        command_string += &#34; &#39;%s&#39;&#34; % str(arg)

    # - Adding the kwargs -#
    for k, v in kwargs.items():
        command_string += &#34; -%s &#39;%s&#39;&#34; % (str(k), str(v))

    return command_string


# -------------------------------------------------------------------------------------------------------------------- #
#  Batch Management ================================================================================================== #
# -------------------------------------------------------------------------------------------------------------------- #
def write_slurm_file(command_string, slurm_config=None, name=None):
    &#34;&#34;&#34;
    Writes the ``command_string`` to a SLURM compatible form using the ``slurm_config``
    :param command_string: The command string to add as the executable section of the .slurm file.
    :param slurm_config: the configuration dictionary for slurm. Defaults to calling for a select settings dialog.
    :param name: The name to give to the slurm executable.
    :return: None
    &#34;&#34;&#34;
    #  Intro Debugging
    # ----------------------------------------------------------------------------------------------------------------- #
    modlog.debug(&#34;Writing slurm file with name parameter %s.&#34; % name)

    #  Setup and Management
    # ----------------------------------------------------------------------------------------------------------------- #
    if not name:  # We specify a name - generic
        modlog.debug(&#34;Name parameter was not specified. setting name to generic.&#34;)
        name = &#39;generic&#39;

    if not slurm_config:  # We need to grab it from the user.
        modlog.debug(&#34;slurm configuration was not specified, fetching from file and querying the user.&#34;)

        # - loading the configuration -#
        try:
            slurm_config_default = toml.load(
                os.path.join(CONFIG[&#34;System&#34;][&#34;Directories&#34;][&#34;bin&#34;], &#34;configs&#34;, &#34;SLURM.config&#34;))
        except FileNotFoundError:
            modlog.exception(
                &#34;Failed to find the default slurm config at %s.&#34; % os.path.join(CONFIG[&#34;System&#34;][&#34;Directories&#34;][&#34;bin&#34;],
                                                                                &#34;configs&#34;, &#34;SLURM.config&#34;))
            return False
        except toml.TomlDecodeError:
            modlog.exception(&#34;The file at %s was corrupted or otherwise unusable.&#34; % os.path.join(
                CONFIG[&#34;System&#34;][&#34;Directories&#34;][&#34;bin&#34;], &#34;configs&#34;, &#34;SLURM.config&#34;))
            return False

        # - grabbing settings -#
        modlog.debug(&#34;Grabbing slurm settings from user.&#34;)
        slurm_config = get_options(slurm_config_default, &#34;Slurm Batch Settings&#34;)
        modlog.debug(&#34;Successfully obtained user settings.&#34;)

    #  Writing the slurm file
    # ----------------------------------------------------------------------------------------------------------------- #
    date = datetime.now().strftime(&#39;%m-%d_%H-%M&#39;)
    filename = &#34;%s_%s.SLURM&#34; % (name, date)
    slurm_script = &#34;#!/bin/csh\n\n&#34;  # predefined slurm script.

    # - Adding the batch settings -#
    for setting, value in slurm_config[&#34;Settings&#34;].items():
        slurm_script += &#34;#SBATCH -%s %s\n&#34; % (setting, value[&#34;v&#34;])

    # - Adding the output -#
    path = os.path.join(CONFIG[&#34;System&#34;][&#34;Directories&#34;][&#34;SLURM_output_directory&#34;], pt.Path(filename).stem,
                        slurm_config[&#34;files&#34;][&#34;format&#34;][&#34;v&#34;] % {&#34;name&#34;: name,
                                                                &#34;date&#34;: date})
    slurm_script += &#34;#SBATCH -o %s.out\n&#34; % path
    slurm_script += &#34;#SBATCH -e %s.err\n\n\n%s&#34; % (path, command_string)

    modlog.debug(&#34;Successfully wrote the slurm script to a memory string.&#34;)

    #  Generating necessary files / folders
    # ----------------------------------------------------------------------------------------------------------------- #
    if not os.path.exists(
            os.path.join(CONFIG[&#34;System&#34;][&#34;Directories&#34;][&#34;SLURM_output_directory&#34;], pt.Path(filename).stem)):
        pt.Path(os.path.join(CONFIG[&#34;System&#34;][&#34;Directories&#34;][&#34;SLURM_output_directory&#34;], pt.Path(filename).stem)).mkdir(
            parents=True)
        modlog.debug(&#34;Generated the output file at %s&#34; % (
            os.path.join(CONFIG[&#34;System&#34;][&#34;Directories&#34;][&#34;SLURM_output_directory&#34;], pt.Path(filename).stem)))
    else:
        pass

    #  Writing the file
    # ----------------------------------------------------------------------------------------------------------------- #
    with open(os.path.join(CONFIG[&#34;System&#34;][&#34;Directories&#34;][&#34;slurm_directory&#34;], filename), &#34;w+&#34;) as f:
        f.write(slurm_script)

    modlog.debug(
        &#34;Completed writing slurm output to %s.&#34; % os.path.join(CONFIG[&#34;System&#34;][&#34;Directories&#34;][&#34;slurm_directory&#34;]))

    return None


# -------------------------------------------------------------------------------------------------------------------- #
# Configuration Management =========================================================================================== #
# -------------------------------------------------------------------------------------------------------------------- #
def write_ramses_nml(settings: dict, output_location: str) -&gt; bool:
    &#34;&#34;&#34;
    Writes a RAMSES nml file at the output_location using the settings specified in ``settings``.

    **Processes:**

    1. Removes the meta key from the settings.
    2. Converts the memory type to the correct form.
    3. Removes disabled keys
    4. Removes software non compatible headers.
    5. Manages the initial condition file&#39;s location.


    :param settings: The settings
    :param output_location: The output location
    :return: True if pass, Fail if not.
    &#34;&#34;&#34;
    #  Debugging and setup
    # ----------------------------------------------------------------------------------------------------------------- #
    modlog.debug(&#34;Generating ramses nml file at %s.&#34; % output_location)

    # Managing the software details.
    # ----------------------------------------------------------------------------------------------------------------- #
    software, ic_file, mem_mode = settings[&#34;META&#34;][&#34;software&#34;][&#34;v&#34;], settings[&#34;META&#34;][&#34;ic_file&#34;][&#34;v&#34;], \
                                  settings[&#34;META&#34;][&#34;Memory&#34;][&#34;mode&#34;][&#34;v&#34;]

    modlog.debug(&#34;software=%s, ic_file=%s, mem_mode=%s.&#34; % (software, ic_file, mem_mode))

    with open(os.path.join(pt.Path(__file__).parents[1], &#34;bin&#34;, &#34;lib&#34;, &#34;imp&#34;, &#34;types.json&#34;), &#34;r&#34;) as type_file:
        types = json.load(type_file)

    # - Checking the software is actually implemented
    if software not in types[&#34;software&#34;][&#34;RAMSES&#34;]:
        raise ValueError(&#34;The software %s does not match any of the implemented softwares!&#34; % software)

    # - Managing locations
    for k, v in types[&#34;software&#34;][&#34;RAMSES&#34;][software][&#34;header_control&#34;].items():
        settings[k][&#34;enabled&#34;][&#34;v&#34;] = v
        modlog.debug(&#34;Enabled %s&#34; % k if v else &#34;Disabled %s&#34; % k)

    # - managing the IC location -#
    for loc in types[&#34;software&#34;][&#34;RAMSES&#34;][software][&#34;ic_headers&#34;]:
        setInDict(settings, loc + [&#34;v&#34;], ic_file)
        modlog.debug(&#34;Setting %s to the ic_file %s.&#34; % (loc, ic_file))

    # - managing the memory type -#
    for setting in [&#34;ngrid&#34;, &#34;npart&#34;]:
        settings[&#34;AMR_PARAMS&#34;][setting + str(mem_mode)] = {
            &#34;v&#34;: settings[&#34;AMR_PARAMS&#34;][setting][&#34;v&#34;],
            &#34;d&#34;: &#34;&#34;,
            &#34;i&#34;: &#34;&#34;
        }
        del settings[&#34;AMR_PARAMS&#34;][setting]

    ramses_nml_string = &#34;&#34;
    #  Writing
    # ----------------------------------------------------------------------------------------------------------------- #
    for k, v in settings.items():  # -&gt; cycle through all of the values seeking headers.
        if k != &#34;META&#34;:  # -&gt; We should actually be doing something with this
            # - Checking -#
            check = (len(v) &gt; 0 if &#34;enabled&#34; not in v else (len(v) &gt; 1 and v[&#34;enabled&#34;][&#34;v&#34;]))
            if check:
                ramses_nml_string += &#34;&amp;%s\n&#34; % k
                for k_sub, v_sub in v.items():  # -&gt; iterate through the sub set.
                    if k_sub != &#34;enabled&#34;:
                        ramses_nml_string += &#34;%s = %s\n&#34; % (k_sub, v_sub[&#34;v&#34;])
                    else:
                        pass
                ramses_nml_string += &#34;/\n\n&#34;
        else:
            pass

    with open(output_location, &#34;w+&#34;) as nml_file:
        nml_file.write(ramses_nml_string)

    return None


if __name__ == &#39;__main__&#39;:
    write_ramses_nml(toml.load(os.path.join(CONFIG[&#34;System&#34;][&#34;Directories&#34;][&#34;bin&#34;], &#34;configs&#34;, &#34;RAMSES.config&#34;)), &#34;&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="PyHPC.PyHPC_System.io.write_command_string"><code class="name flex">
<span>def <span class="ident">write_command_string</span></span>(<span>command: str, *args, **kwargs) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the corresponding command string in the format ''command arg[0] arg[&hellip;] -k[0] v[0] &hellip; -k[n] v[n].
:param command: The command to run.
:param args: Unflagged arguments to pass through the shell.
:param kwargs: Flagged arguments to pass through the shell with corresponding <b>QUICK</b> keys.
:return: String.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_command_string(command: str, *args, **kwargs) -&gt; str:
    &#34;&#34;&#34;
    Returns the corresponding command string in the format &#39;&#39;command arg[0] arg[...] -k[0] v[0] ... -k[n] v[n].
    :param command: The command to run.
    :param args: Unflagged arguments to pass through the shell.
    :param kwargs: Flagged arguments to pass through the shell with corresponding &lt;b&gt;QUICK&lt;/b&gt; keys.
    :return: String.
    &#34;&#34;&#34;
    modlog.debug(&#34;Writing command %s with args %s and kwargs %s.&#34; % (command, args, kwargs))
    command_string = command

    # - Adding the arguments -#
    for arg in args:
        command_string += &#34; &#39;%s&#39;&#34; % str(arg)

    # - Adding the kwargs -#
    for k, v in kwargs.items():
        command_string += &#34; -%s &#39;%s&#39;&#34; % (str(k), str(v))

    return command_string</code></pre>
</details>
</dd>
<dt id="PyHPC.PyHPC_System.io.write_ramses_nml"><code class="name flex">
<span>def <span class="ident">write_ramses_nml</span></span>(<span>settings: dict, output_location: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Writes a RAMSES nml file at the output_location using the settings specified in <code>settings</code>.</p>
<p><strong>Processes:</strong></p>
<ol>
<li>Removes the meta key from the settings.</li>
<li>Converts the memory type to the correct form.</li>
<li>Removes disabled keys</li>
<li>Removes software non compatible headers.</li>
<li>Manages the initial condition file's location.</li>
</ol>
<p>:param settings: The settings
:param output_location: The output location
:return: True if pass, Fail if not.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_ramses_nml(settings: dict, output_location: str) -&gt; bool:
    &#34;&#34;&#34;
    Writes a RAMSES nml file at the output_location using the settings specified in ``settings``.

    **Processes:**

    1. Removes the meta key from the settings.
    2. Converts the memory type to the correct form.
    3. Removes disabled keys
    4. Removes software non compatible headers.
    5. Manages the initial condition file&#39;s location.


    :param settings: The settings
    :param output_location: The output location
    :return: True if pass, Fail if not.
    &#34;&#34;&#34;
    #  Debugging and setup
    # ----------------------------------------------------------------------------------------------------------------- #
    modlog.debug(&#34;Generating ramses nml file at %s.&#34; % output_location)

    # Managing the software details.
    # ----------------------------------------------------------------------------------------------------------------- #
    software, ic_file, mem_mode = settings[&#34;META&#34;][&#34;software&#34;][&#34;v&#34;], settings[&#34;META&#34;][&#34;ic_file&#34;][&#34;v&#34;], \
                                  settings[&#34;META&#34;][&#34;Memory&#34;][&#34;mode&#34;][&#34;v&#34;]

    modlog.debug(&#34;software=%s, ic_file=%s, mem_mode=%s.&#34; % (software, ic_file, mem_mode))

    with open(os.path.join(pt.Path(__file__).parents[1], &#34;bin&#34;, &#34;lib&#34;, &#34;imp&#34;, &#34;types.json&#34;), &#34;r&#34;) as type_file:
        types = json.load(type_file)

    # - Checking the software is actually implemented
    if software not in types[&#34;software&#34;][&#34;RAMSES&#34;]:
        raise ValueError(&#34;The software %s does not match any of the implemented softwares!&#34; % software)

    # - Managing locations
    for k, v in types[&#34;software&#34;][&#34;RAMSES&#34;][software][&#34;header_control&#34;].items():
        settings[k][&#34;enabled&#34;][&#34;v&#34;] = v
        modlog.debug(&#34;Enabled %s&#34; % k if v else &#34;Disabled %s&#34; % k)

    # - managing the IC location -#
    for loc in types[&#34;software&#34;][&#34;RAMSES&#34;][software][&#34;ic_headers&#34;]:
        setInDict(settings, loc + [&#34;v&#34;], ic_file)
        modlog.debug(&#34;Setting %s to the ic_file %s.&#34; % (loc, ic_file))

    # - managing the memory type -#
    for setting in [&#34;ngrid&#34;, &#34;npart&#34;]:
        settings[&#34;AMR_PARAMS&#34;][setting + str(mem_mode)] = {
            &#34;v&#34;: settings[&#34;AMR_PARAMS&#34;][setting][&#34;v&#34;],
            &#34;d&#34;: &#34;&#34;,
            &#34;i&#34;: &#34;&#34;
        }
        del settings[&#34;AMR_PARAMS&#34;][setting]

    ramses_nml_string = &#34;&#34;
    #  Writing
    # ----------------------------------------------------------------------------------------------------------------- #
    for k, v in settings.items():  # -&gt; cycle through all of the values seeking headers.
        if k != &#34;META&#34;:  # -&gt; We should actually be doing something with this
            # - Checking -#
            check = (len(v) &gt; 0 if &#34;enabled&#34; not in v else (len(v) &gt; 1 and v[&#34;enabled&#34;][&#34;v&#34;]))
            if check:
                ramses_nml_string += &#34;&amp;%s\n&#34; % k
                for k_sub, v_sub in v.items():  # -&gt; iterate through the sub set.
                    if k_sub != &#34;enabled&#34;:
                        ramses_nml_string += &#34;%s = %s\n&#34; % (k_sub, v_sub[&#34;v&#34;])
                    else:
                        pass
                ramses_nml_string += &#34;/\n\n&#34;
        else:
            pass

    with open(output_location, &#34;w+&#34;) as nml_file:
        nml_file.write(ramses_nml_string)

    return None</code></pre>
</details>
</dd>
<dt id="PyHPC.PyHPC_System.io.write_slurm_file"><code class="name flex">
<span>def <span class="ident">write_slurm_file</span></span>(<span>command_string, slurm_config=None, name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Writes the <code>command_string</code> to a SLURM compatible form using the <code>slurm_config</code>
:param command_string: The command string to add as the executable section of the .slurm file.
:param slurm_config: the configuration dictionary for slurm. Defaults to calling for a select settings dialog.
:param name: The name to give to the slurm executable.
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_slurm_file(command_string, slurm_config=None, name=None):
    &#34;&#34;&#34;
    Writes the ``command_string`` to a SLURM compatible form using the ``slurm_config``
    :param command_string: The command string to add as the executable section of the .slurm file.
    :param slurm_config: the configuration dictionary for slurm. Defaults to calling for a select settings dialog.
    :param name: The name to give to the slurm executable.
    :return: None
    &#34;&#34;&#34;
    #  Intro Debugging
    # ----------------------------------------------------------------------------------------------------------------- #
    modlog.debug(&#34;Writing slurm file with name parameter %s.&#34; % name)

    #  Setup and Management
    # ----------------------------------------------------------------------------------------------------------------- #
    if not name:  # We specify a name - generic
        modlog.debug(&#34;Name parameter was not specified. setting name to generic.&#34;)
        name = &#39;generic&#39;

    if not slurm_config:  # We need to grab it from the user.
        modlog.debug(&#34;slurm configuration was not specified, fetching from file and querying the user.&#34;)

        # - loading the configuration -#
        try:
            slurm_config_default = toml.load(
                os.path.join(CONFIG[&#34;System&#34;][&#34;Directories&#34;][&#34;bin&#34;], &#34;configs&#34;, &#34;SLURM.config&#34;))
        except FileNotFoundError:
            modlog.exception(
                &#34;Failed to find the default slurm config at %s.&#34; % os.path.join(CONFIG[&#34;System&#34;][&#34;Directories&#34;][&#34;bin&#34;],
                                                                                &#34;configs&#34;, &#34;SLURM.config&#34;))
            return False
        except toml.TomlDecodeError:
            modlog.exception(&#34;The file at %s was corrupted or otherwise unusable.&#34; % os.path.join(
                CONFIG[&#34;System&#34;][&#34;Directories&#34;][&#34;bin&#34;], &#34;configs&#34;, &#34;SLURM.config&#34;))
            return False

        # - grabbing settings -#
        modlog.debug(&#34;Grabbing slurm settings from user.&#34;)
        slurm_config = get_options(slurm_config_default, &#34;Slurm Batch Settings&#34;)
        modlog.debug(&#34;Successfully obtained user settings.&#34;)

    #  Writing the slurm file
    # ----------------------------------------------------------------------------------------------------------------- #
    date = datetime.now().strftime(&#39;%m-%d_%H-%M&#39;)
    filename = &#34;%s_%s.SLURM&#34; % (name, date)
    slurm_script = &#34;#!/bin/csh\n\n&#34;  # predefined slurm script.

    # - Adding the batch settings -#
    for setting, value in slurm_config[&#34;Settings&#34;].items():
        slurm_script += &#34;#SBATCH -%s %s\n&#34; % (setting, value[&#34;v&#34;])

    # - Adding the output -#
    path = os.path.join(CONFIG[&#34;System&#34;][&#34;Directories&#34;][&#34;SLURM_output_directory&#34;], pt.Path(filename).stem,
                        slurm_config[&#34;files&#34;][&#34;format&#34;][&#34;v&#34;] % {&#34;name&#34;: name,
                                                                &#34;date&#34;: date})
    slurm_script += &#34;#SBATCH -o %s.out\n&#34; % path
    slurm_script += &#34;#SBATCH -e %s.err\n\n\n%s&#34; % (path, command_string)

    modlog.debug(&#34;Successfully wrote the slurm script to a memory string.&#34;)

    #  Generating necessary files / folders
    # ----------------------------------------------------------------------------------------------------------------- #
    if not os.path.exists(
            os.path.join(CONFIG[&#34;System&#34;][&#34;Directories&#34;][&#34;SLURM_output_directory&#34;], pt.Path(filename).stem)):
        pt.Path(os.path.join(CONFIG[&#34;System&#34;][&#34;Directories&#34;][&#34;SLURM_output_directory&#34;], pt.Path(filename).stem)).mkdir(
            parents=True)
        modlog.debug(&#34;Generated the output file at %s&#34; % (
            os.path.join(CONFIG[&#34;System&#34;][&#34;Directories&#34;][&#34;SLURM_output_directory&#34;], pt.Path(filename).stem)))
    else:
        pass

    #  Writing the file
    # ----------------------------------------------------------------------------------------------------------------- #
    with open(os.path.join(CONFIG[&#34;System&#34;][&#34;Directories&#34;][&#34;slurm_directory&#34;], filename), &#34;w+&#34;) as f:
        f.write(slurm_script)

    modlog.debug(
        &#34;Completed writing slurm output to %s.&#34; % os.path.join(CONFIG[&#34;System&#34;][&#34;Directories&#34;][&#34;slurm_directory&#34;]))

    return None</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="PyHPC.PyHPC_System" href="index.html">PyHPC.PyHPC_System</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="PyHPC.PyHPC_System.io.write_command_string" href="#PyHPC.PyHPC_System.io.write_command_string">write_command_string</a></code></li>
<li><code><a title="PyHPC.PyHPC_System.io.write_ramses_nml" href="#PyHPC.PyHPC_System.io.write_ramses_nml">write_ramses_nml</a></code></li>
<li><code><a title="PyHPC.PyHPC_System.io.write_slurm_file" href="#PyHPC.PyHPC_System.io.write_slurm_file">write_slurm_file</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>